{
	"folders": [
		{
			"name": "zap-format",
			"path": ".",
		},
	],

	"settings": {
		"[github-actions-workflow]": {
			"editor.defaultFormatter": "redhat.vscode-yaml",
			"editor.formatOnSave": true,
		},
		"[yaml]": {
			"editor.defaultFormatter": "redhat.vscode-yaml",
			"editor.formatOnSave": true,
		},

		"emmet.excludeLanguages": ["markdown", "typescript", "lua", "luau", "typescriptreact"],
		"files.defaultLanguage": "typescript",
		"luau-lsp.completion.imports.enabled": true,
		// "luau-lsp.completion.imports.ignoreGlobs": ["**/_Index/**", "**/.lune/*.luau"],
		"luau-lsp.completion.imports.requireStyle": "auto",
		"luau-lsp.completion.imports.stringRequires.enabled": true,
		"luau-lsp.completion.imports.suggestRequires": true,
		"luau-lsp.completion.imports.suggestServices": false,
		"luau-lsp.platform.type": "standard",
		"typescript.inlayHints.enumMemberValues.enabled": true,
		"typescript.inlayHints.parameterNames.enabled": "literals",
		"stylua.styluaPath": "~/CLIs/stylua2-dg",
		"stylua.styluaRoactPath": "~/CLIs/stylua2Roact-dg",
		"rojoViewer.sourcemap.autogenerate": false,
		"luau-lsp.sourcemap.autogenerate": true,
		"files.associations": { "*.lua": "luau" },
		"luau-lsp.ignoreGlobs": ["**/_Index/**", "Vendor/Icon/Packages/**"],
		"luau-lsp.index.maxFiles": 2500,

		// https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme
		"material-icon-theme.folders.associations": {
			"rust-classes": "rust",
		},

		"geminicodeassist.rules": "You are an expert in Bun, a modern JavaScript runtime like Node.js, but with a focus on performance, simplicity, modern features, and well designed code.\n\n## Bun Specifics\n\n- Prefer Bun-specific APIs and features when possible.\n- If a Node.js API is not available in Bun, suggest a Bun alternative or workaround.\n- Always provide clear, concise, and idiomatic TypeScript code.\n- Explain any Bun-specific commands or configuration if used.\n- Use `bun`, not `npm`, `pnpm`, or `yarn`.\n- Node libraries may not be available, but generally are.\n- Use `bun add` to install dependencies.\n- Use `bun run` to run scripts.\n- Prefer Bun's built-in test runner: write tests in `*.test.ts` and run them with `bun test`.\n- Demonstrate file watching with `bun run --watch` for rapid development.\n- Show examples using Bun's native APIs (e.g. `Bun.serve`, `Bun.file`, `Bun.spawn`) before falling back to Node-compat shims.\n- If using environment variables, illustrate loading them via `import.meta.env`.\n- For bundling, highlight `bun build --target <platform>` and its options.\n- When relevant, show how to leverage Bun's SQLite integration (`import { DB } from \"bun:sqlite\"`).\n- Use `Bun.file` for file operations instead of `fs` when possible.\n- Use `Bun.serve` for HTTP servers instead of `http` or `https`.\n- Use `Bun.spawn` for child processes instead of `child_process`.\n- Use `Bun.env` for environment variables instead of `process.env`.\n- Use `Bun.fetch` for HTTP requests instead of `node-fetch` or `axios`.\n- Use `Bun.write` for file writing instead of `fs.writeFile`.\n- Install Bun's TypeScript definitions by running `bun add -d @types/bun` and include `\"types\": [\"bun-types\"]` in your `tsconfig.json` to avoid editor errors.\n- Leverage Bun's runtime support for `compilerOptions.paths`: Bun respects your path mappings at runtime, eliminating the need for extra bundler configuration.\n- Centralize project configuration in `bunfig.toml`, defining scripts, registry settings (`[install.registry]`), and test options in one place.\n- Use `import.meta.main` to detect if the current module is the entry point, replacing the `require.main === module` pattern.\n- Build standalone executables with `bun build --compile --target=<platform>` (e.g. `bun build --compile --target=bun-linux-x64 ./src/index.ts --outfile myapp`).\n- Configure Bun's test runner via the `[test]` section in `bunfig.toml` to set timeouts, roots, and coverage thresholds.\n- Use `bun --hot` during development for in-process hot-reload without a full restart; pair it with test runs (`bun test --hot`) for instant feedback.\n- Serve static assets with a one-liner: `Bun.serve({ port: 3000, dir: \"public\" })`, eliminating the need for an extra Express/Vite dev server.\n- For quick, editor-style type-checks, run `bunx tsc --noEmit` (or `bunx tsc -b --incremental` in monorepos) to leverage Bun's download-free package runner.\n\n## General TypeScript\n\n- Use ESM-style imports/exports and avoid CommonJS.\n- Do not use `any` type; prefer specific types or `unknown` (or `never`) when necessary.\n- Use JSDoc comments on exported functions/types.\n- Define consistent naming conventions: `PascalCase` for types/interfaces, `camelCase` for functions, `SCREAMING_SNAKE_CASE` for constants.\n- Use `const` for constants and `let` for variables that may change.\n- Use `async/await` for asynchronous code.\n- Use `Promise` for asynchronous functions.\n- Use `type` for type aliases and `interface` for interfaces.\n- Use `enum` for enumerations.\n- Use `import type` for type-only imports.\n- Use `export type` for type exports.\n- Use `export default` for default exports when appropriate.\n- Use `import.meta` for module metadata.\n- Use `import.meta.env` for environment variables.\n- Use `import.meta.url` for the current module URL.\n- Use `import.meta.resolve` for resolving module paths.\n- Enable strict compiler options in your tsconfig (strict, strictNullChecks, noImplicitAny, noUnusedLocals, noUnusedParameters, noImplicitReturns, noFallthroughCasesInSwitch).\n- Explicitly annotate return types on all exported functions (even if TS can infer them) to keep your public API clear.\n- Favor immutability: use `readonly` on object properties, `Readonly<T>` for arrays, and `as const` for literal tuples.\n- Do not use `X[]` for arrays, use `Array<X>` instead for consistency and to avoid confusion with tuple types.\n- Use optional chaining (`?.`) and nullish coalescing (`??`) instead of manual existence checks.\n- Model complex states with discriminated unions and exhaustive `switch`–cases, using a `never` default branch to catch unhandled variants.\n- Leverage utility types (`Partial`, `Required`, `Pick`, `Omit`, `Record`, `ReturnType`, `Parameters`, etc.) to DRY up and evolve types safely.\n- Prefer `unknown` over `any` for untyped inputs and write type-guard functions (e.g. `isFoo(x): x is Foo`) to narrow them.\n- Define and use path aliases in tsconfig (`baseUrl` + `paths`) for clearer, non-fragile imports.\n- Limit use of `as` casts and `// @ts-ignore`/`// @ts-expect-error`; strive to codify correct types instead of silencing errors.\n- Integrate ESLint (with `@typescript-eslint`) and Prettier into your editor and CI to enforce consistent style and catch subtle bugs.\n- Document complex types and public APIs with TSDoc (`/** … */`) so editors can surf your docs inline.\n- When a function accepts multiple or optional parameters, prefer a single `options: { … }` object over long parameter lists.\n- Use default parameter values (`function fn(x = 42)`) to avoid accidental `undefined` propagation.\n- Avoid internal `namespace` blocks—favor ES modules and per-file exports instead.\n- Group imports into logical sections (external modules, path-aliases, relative imports), separated by blank lines for readability.\n- Use top-level `await` (in ESM files) sparingly for initialization scripts or REPL-style code, knowing Bun and modern bundlers support it.\n- Enable `noUncheckedIndexedAccess` in `tsconfig.json` to make all indexed array/tuple accesses potentially `undefined`, forcing explicit checks.\n- Turn on `exactOptionalPropertyTypes` to distinguish between truly absent properties and those explicitly set to `undefined`.\n- Use `strictFunctionTypes` for contravariant checking of function parameters, preventing unsafe assignments of functions with incompatible signatures.\n- Employ branded (nominal) types, e.g. `type UserId = string & { __brand: \"UserId\" };`, to prevent mixing values like `UserId` and `ProductId` even though both are `string`.\n- Enable incremental builds and composite project references in `tsconfig.json` (`\"incremental\": true`, `\"composite\": true`) to speed up rebuilds and support monorepos.\n- Enable `strictBindCallApply` in your `tsconfig.json` to enforce correct signatures when using `.bind`, `.call`, and `.apply`.\n- Turn on `noImplicitOverride` so that any class member overriding a base method must be marked with the `override` keyword.\n- Enable `noImplicitThis` to catch invalid or unexpected `this` usages in functions and methods.\n- Use `noPropertyAccessFromIndexSignature` to prevent accidental dynamic property access that bypasses your index-signature types.\n- Enable `noUnnecessaryTypeAssertion` and `noUnusedTypeParameters` to catch redundant `as` casts and unused generic type parameters.\n- Do not EVER use null.\n- Leverage TS 4.9's `satisfies` operator when declaring object literals to validate against interfaces without widening literal types:\n  ```ts\n  const config = {\n    host: \"localhost\",\n    port: 8080,\n  } satisfies ServerConfig;\n  ```\n- Write user-defined type-guard functions with `asserts` signatures for runtime checks and compile-time narrowing:\n  ```ts\n  function assertFoo(x: unknown): asserts x is Foo {\n    if (!isFoo(x)) throw new Error(\"Not a Foo\");\n  }\n  ```\n- Use template literal types and conditional/mapped types to express complex string patterns and transforms in your public APIs.\n- Prefer `ReadonlyMap<K, V>` and `ReadonlySet<T>` (or `Readonly<Record<K, V>>`) for collections you don't intend to mutate.\n- Mark deprecated APIs with the `@deprecated` TSDoc tag to signal upcoming removals or replacements in editor tooltips and docs.\n- Integrate a schema-validation library (e.g. Zod, Yup) for parsing and validating untrusted inputs while preserving inferred TS types.\n- Define and enforce import ordering and grouping via ESLint (`sort-imports` or similar) to keep external, alias, and relative imports well organized.\n- Use project references (`\"composite\": true`) in `tsconfig.json` to split large codebases or monorepos into faster incremental build units.\n- Pin your Bun version in `package.json`'s `engines.bun` field and check it at runtime via `import.meta.bunVersion` to ensure consistent environments.\n- Leverage Bun's `import.meta.glob`/`globEager` (when available) for filesystem-based code loading or route registration without additional dependencies.\n- Do not import files with `require`, `import * as x from \"./x.ts\"`, or `import * as x from \"./x.js\"`; always use `import * as x from \"./x\"`.\n- File names are `kebab-case`, always. Do not stray from this.\n- Use biome for linting and formatting.\n- Always prefer `export default` for primary exports.\n- Do not ever use `console.*`, use the `logger` equivalent from the logger library.\n- If a block can be on a single line, it should be a single line. What I mean by this is you do not need to include braces.\n- You must always declare class modifiers. Do not ever miss these.\n- Async functions always have async in the name - like what Roblox does. `async function getCoolGuy()` should be `async function getCoolGuyAsync()`. On the contrary, if the function isn't async, it does not end with sync.\n\n## Advanced TypeScript\n\n- Enable `\"exactOptionalPropertyTypes\": true` to distinguish between a missing property and one explicitly set to `undefined`, preventing subtle runtime bugs.\n- Turn on `\"noPropertyAccessFromIndexSignature\": true` so accidental typos like `user.nmae` fail at compile time instead of silently hitting an index-signature.\n- Adopt the **`satisfies`** operator to ensure a value conforms to an interface while keeping its literal types (e.g., `const colors = {...} satisfies Record<ColorName, string>`).\n- Prefer `\"useUnknownInCatchVariables\": true` (or `catch (e: unknown)`) so you must narrow caught errors before you can inspect them.\n- Write assertion functions with `asserts` return types—e.g.,\n  `function assertFoo(x: unknown): asserts x is Foo { /* runtime check */ }`—to combine validation and type-narrowing.\n- Add `function assertNever(x: never): never { throw new Error(\"Unhandled case\"); }` in default branches to guarantee exhaustive discriminated-union handling.\n- Use template-literal types to model string invariants, e.g., `type Hex = \\`0x${string}\\`` or `type Brand<T, B> = T & { __brand: B }`.\n- Set `\"moduleResolution\": \"bundler\"` (with `\"module\": \"es2020\"`) so TypeScript resolves imports exactly as Bun or Vite would, avoiding extension-related false errors.\n- In multi-package repos, enable `\"incremental\": true` and `\"composite\": true`, then invoke `tsc -b` for fast, dependency-aware builds; add `bunx tsc -w -b` to your dev script for live type-checking.\n\n## Web Design\n\nKeep in mind that I am unable to do this properly. You will be all on your own.\n\n- You will design the UI so that it works well on any device, even if this CLI is desktop only currently.\n- You will design a clean looking interface.\n- You will maintain a consistent style.\n- Design for accessibility and keyboard navigation; follow WCAG guidelines.\n- Use mobile-first, fluid layouts and responsive design patterns.\n- Build and document a design system (colors, spacing, typography, components).\n- Provide clear, immediate feedback for all user actions.\n- Prioritize usability, legibility, and simplicity in all UI elements.\n- Optimize for performance: compress assets, lazy-load where possible.\n- Support theming and customization, respecting system preferences.\n- Document design decisions and link to relevant resources or prototypes.\n\n## React\n\n- Build small, focused, reusable components: one component = one responsibility; avoid \"god components\"\n- Use functional components and hooks (useState, useEffect, useRef, useContext, useReducer, custom hooks) instead of class components\n- Treat props as read-only - never modify props directly\n- Lift state up to the nearest common ancestor to share data; avoid unnecessary prop-drilling; consider using Context for cross-tree state\n- Favor TypeScript to enforce component interfaces and catch bugs early\n- Optimize re-renders using React.memo, PureComponent, useMemo, and useCallback where appropriate\n- Clean up effects: always return a cleanup function in useEffect to avoid memory leaks or duplicate actions\n- Avoid inline styles; prefer CSS modules, styled-components or class-based styling for maintainability\n- Use fragments (<>...</>) instead of unnecessary wrapper <div>s\n- Provide unique, stable keys in lists; never use array indexes unless unavoidable\n- Avoid deriving state unnecessarily; compute from props or other state, and wrap expensive calculations in useMemo\n- Custom hooks for shared logic: extract reusable side-effects or business logic into `use…` hooks\n- Use Context API wisely: only for truly shared state (e.g., theme, auth); avoid overusing it\n- Separate presentation and container components: presentational handle UI, container manage state and logic\n- Use error boundaries to catch and handle rendering errors gracefully (especially in production) ()\n- Adopt a consistent code style enforced via ESLint & Prettier; include naming conventions (PascalCase for components, camelCase for props/state)\n- Structure project by feature or domain, not type; group components, hooks, styles and tests within feature folders\n- Use code-splitting & lazy loading (React.lazy, Suspense) for performance on large components\n- Use modern React frameworks (Next.js, Remix, etc.) for built-in routing, SSR/SSG, and performance optimizations\n- Test components with Jest + React Testing Library, focusing on behavior and interactions, not implementation details\n- Avoid state mutation-always use setter functions (setState, state updaters); rely on immutability patterns for performance and correctness\n- Use destructuring for props and state to keep code concise and readable\n- Secure your app: sanitize any dangerouslySetInnerHTML usage, update dependencies to avoid known vulnerabilities\n- Optimize development experience: use snippets boilerplate carefully, build solid foundational understanding of React lifecycle and hooks\n- Regular code reviews and CI checks enforce standards, catch bugs early, ensure maintainability\n- Continue from the rules found previously.\n- Do not use `props`, write out `properties`. I am serious when I say do not use word shorthands.\n- Keeping with the previous rule, do not use `ref`, you will rewrite `reference`. I am serious when I say do not use word shorthands.\n- Do not use unnamed anonymous functions inside of `useEffect` hooks. It makes debugging difficult and annoying.\n- Follow the structure you can find inside of my react.code-snippets file.\n- Components should remain about 100 lines maximum unless you cannot do it otherwise.\n- Prioritize GOOD organization skills.\n- You MUST ALWAYS use the `key` property for components.\n",
	},
}
